{
  
    
        "post0": {
            "title": "Learning Molecular Representation using Graph Neural Network - Molecular Graph",
            "content": "Motivation . I have used chemprop previously and got interested in how it works internally. I&#39;ve read their papers several times, but I&#39;m not a machine learning researcher, and how it handles the molecular reprentation using the graph neural network was not entirely clear to me. So, here I&#39;ll spend some time going through their code and try to understand it my own way. Most of the code was initially taken from the chemprop repository and I striped away the parts that I don&#39;t need for clarity. . %matplotlib inline import matplotlib.pyplot as plt import matplotlib from io import BytesIO import pandas as pd import numpy as np from IPython.display import SVG # RDKit import rdkit from rdkit.Chem import PandasTools from rdkit import Chem from rdkit.Chem import AllChem from rdkit.Chem import DataStructs from rdkit.Chem import rdMolDescriptors from rdkit.Chem import rdRGroupDecomposition from rdkit.Chem.Draw import IPythonConsole #Needed to show molecules from rdkit.Chem import Draw from rdkit.Chem import rdDepictor from rdkit.Chem.Draw import rdMolDraw2D from rdkit.Chem.Draw.MolDrawing import MolDrawing, DrawingOptions #Only needed if modifying defaults DrawingOptions.bondLineWidth=1.8 IPythonConsole.ipython_useSVG=True from rdkit import RDLogger RDLogger.DisableLog(&#39;rdApp.warning&#39;) print(rdkit.__version__) # pytorch import torch from torch.utils.data import DataLoader, Dataset, Sampler from torch import nn . . 2020.03.2 . Message passing neural network (MPNN) . Chemprop adopts a variant of graph neural network called &quot;directed message passing neural network (D-MPNN)&quot;. Let&#39;s first talk about MPNN and discuss the difference between the MPNN and D-MPNN later. . MPNN is a model that operates on an undirected graph, $G$ with a set of nodes $v$ and edges $e$. This is appealing because molecules can be thought as a graph with nodes (atoms) and edges (bonds). . . MPNN operates in two phases; molecular encoding phase and the feed-forward phase (the paper uses &quot;message passing phase&quot; and &quot;readout phase&quot;, respectively). In the molecular encoding phase, the features in the atoms and bonds are passed around T times to build a molecular representation of the molecule and the molecular properties are predicted in the feed-forward phase. The parameter T is also called &quot;depth&quot; and represents how &quot;far&quot; each nodes can &quot;see&quot;. . . Compared to a typical MPNN, the package chemprop adopts directed MPNN (D-MPNN) architecture using bond features. Although the molecular graph does not have a direction, one can treat each bond as two directed edges that goes opposite direction. One of the advantage of this approach is to prevent totters (message that goes back to itself because the first node is the its neighbor of neighbor). chemprop also uses bond feature, which is concatenated feature vector of atom and bond feature vectors. . Let&#39;s take a look at how chemprop featurizes atom and bond: . Atom Features . # we will define a class which holds various parameter for D-MPNN class TrainArgs: smiles_column = None no_cuda = False gpu = None num_workers = 8 batch_size = 50 atom_descriptors = None no_cache_mol = False dataset_type = &#39;regression&#39; task_names = [] seed = 0 atom_messages = False hidden_size = 300 bias = False depth = 3 dropout = 0.0 undirected = False aggregation = &#39;mean&#39; aggregation_norm = 100 @property def device(self) -&gt; torch.device: &quot;&quot;&quot;The :code:`torch.device` on which to load and process data and models.&quot;&quot;&quot; if not self.cuda: return torch.device(&#39;cpu&#39;) return torch.device(&#39;cuda&#39;, self.gpu) @device.setter def device(self, device: torch.device) -&gt; None: self.cuda = device.type == &#39;cuda&#39; self.gpu = device.index @property def cuda(self) -&gt; bool: &quot;&quot;&quot;Whether to use CUDA (i.e., GPUs) or not.&quot;&quot;&quot; return not self.no_cuda and torch.cuda.is_available() @cuda.setter def cuda(self, cuda: bool) -&gt; None: self.no_cuda = not cuda args = TrainArgs() . . For atom and bond features, we can take a look at the atom_features and bond_features function below. For example, the atom feature vector consists of one-hot encoding of atomic number, degree, formal charge, chirality, number of hydrogens, and hybridization. And the bond feature vector consists of one-hot encoding of bond type (single, double, triple, aromatic) and whether the bond is conjugated or not and whether in the ring or not. . MAX_ATOMIC_NUM = 100 ATOM_FEATURES = { &#39;atomic_num&#39;: list(range(MAX_ATOMIC_NUM)), &#39;degree&#39;: [0, 1, 2, 3, 4, 5], &#39;formal_charge&#39;: [-1, -2, 1, 2, 0], &#39;chiral_tag&#39;: [0, 1, 2, 3], &#39;num_Hs&#39;: [0, 1, 2, 3, 4], &#39;hybridization&#39;: [ Chem.rdchem.HybridizationType.SP, Chem.rdchem.HybridizationType.SP2, Chem.rdchem.HybridizationType.SP3, Chem.rdchem.HybridizationType.SP3D, Chem.rdchem.HybridizationType.SP3D2 ], } # Distance feature sizes PATH_DISTANCE_BINS = list(range(10)) THREE_D_DISTANCE_MAX = 20 THREE_D_DISTANCE_STEP = 1 THREE_D_DISTANCE_BINS = list(range(0, THREE_D_DISTANCE_MAX + 1, THREE_D_DISTANCE_STEP)) # len(choices) + 1 to include room for uncommon values; + 2 at end for IsAromatic and mass ATOM_FDIM = sum(len(choices) + 1 for choices in ATOM_FEATURES.values()) + 2 EXTRA_ATOM_FDIM = 0 BOND_FDIM = 14 def get_atom_fdim(): &quot;&quot;&quot;Gets the dimensionality of the atom feature vector.&quot;&quot;&quot; return ATOM_FDIM + EXTRA_ATOM_FDIM def get_bond_fdim(atom_messages=False): &quot;&quot;&quot;Gets the dimensionality of the bond feature vector. &quot;&quot;&quot; return BOND_FDIM + (not atom_messages) * get_atom_fdim() def onek_encoding_unk(value: int, choices: List[int]): encoding = [0] * (len(choices) + 1) index = choices.index(value) if value in choices else -1 encoding[index] = 1 return encoding def atom_features(atom: Chem.rdchem.Atom, functional_groups: List[int] = None): &quot;&quot;&quot;Builds a feature vector for an atom. &quot;&quot;&quot; features = onek_encoding_unk(atom.GetAtomicNum() - 1, ATOM_FEATURES[&#39;atomic_num&#39;]) + onek_encoding_unk(atom.GetTotalDegree(), ATOM_FEATURES[&#39;degree&#39;]) + onek_encoding_unk(atom.GetFormalCharge(), ATOM_FEATURES[&#39;formal_charge&#39;]) + onek_encoding_unk(int(atom.GetChiralTag()), ATOM_FEATURES[&#39;chiral_tag&#39;]) + onek_encoding_unk(int(atom.GetTotalNumHs()), ATOM_FEATURES[&#39;num_Hs&#39;]) + onek_encoding_unk(int(atom.GetHybridization()), ATOM_FEATURES[&#39;hybridization&#39;]) + [1 if atom.GetIsAromatic() else 0] + [atom.GetMass() * 0.01] # scaled to about the same range as other features if functional_groups is not None: features += functional_groups return features def bond_features(bond: Chem.rdchem.Bond): &quot;&quot;&quot;Builds a feature vector for a bond. &quot;&quot;&quot; if bond is None: fbond = [1] + [0] * (BOND_FDIM - 1) else: bt = bond.GetBondType() fbond = [ 0, # bond is not None bt == Chem.rdchem.BondType.SINGLE, bt == Chem.rdchem.BondType.DOUBLE, bt == Chem.rdchem.BondType.TRIPLE, bt == Chem.rdchem.BondType.AROMATIC, (bond.GetIsConjugated() if bt is not None else 0), (bond.IsInRing() if bt is not None else 0) ] fbond += onek_encoding_unk(int(bond.GetStereo()), list(range(6))) return fbond . Let&#39;s take a look at the example molecule and how atom and bond features actually look like: . smiles = &#39;c1ccccc1NC(=O)CC1cncc1&#39; mol = Chem.MolFromSmiles(smiles) mol . N H O N Below is the feature vector of the every atoms in the molecule. The first 100 elements represents the atomic number, followed by one hot encodings of degree (2), formal charge (0), chiral (false), total number of Hs (1), hybridization (SP2), aromaticity (1). Finally atomic mass (multiplied by 0.01) at the last entry. . feats = [] indices = [] for i in range(mol.GetNumAtoms()): atom = mol.GetAtomWithIdx(i) feat = atom_features(atom) feats.append(feat) indices.append(i) fig = plt.figure(figsize=(12, 0.25 * mol.GetNumAtoms())) ax = fig.add_subplot(111) im = ax.imshow(feats, interpolation=&#39;None&#39;, cmap=&#39;viridis&#39;, aspect=&#39;auto&#39;) plt.xlabel(&#39;atom feature&#39;) plt.ylabel(&#39;atom index&#39;) ax.set_yticks(indices) ax.set_yticklabels(indices) ax.tick_params(left=False) # remove the ticks plt.show() . . The atom index 0 and 7 are very similar since they are both carbon atoms and only slightly different in terms of aromaticity and the number of hydrogens attached. Let&#39;s take a look at the features of atom 0 and 7 side by side so we can see the difference more clearly. . import svgutils.compose as sc import svgutils.transform as sg from ipywidgets import interact, interactive, fixed from IPython.display import SVG from io import BytesIO atom1 = mol.GetAtomWithIdx(0) atom2 = mol.GetAtomWithIdx(7) feat1 = feats[0] feat2 = feats[7] # draw molecule with highlight d = rdMolDraw2D.MolDraw2DSVG(200, 150) rdMolDraw2D.PrepareAndDrawMolecule(d, mol, highlightAtoms=(atom1.GetIdx(), atom2.GetIdx())) d.FinishDrawing() mol_svg = d.GetDrawingText() # draw feature fig = plt.figure(figsize=(3, 0.91), dpi=150) ax = fig.add_subplot(111) im = ax.imshow([feat1, feat2], interpolation=&#39;nearest&#39;, cmap=&#39;viridis&#39;, aspect=&#39;auto&#39;) plt.xlabel(&#39;atom feature&#39;) ax.set_yticks([0, 1]) ax.set_yticklabels([atom1.GetIdx(), atom2.GetIdx()]) img = BytesIO() plt.tight_layout() plt.savefig(img, transparent=True, format=&#39;svg&#39;) plt.close(fig) feat_svg = img.getvalue().decode() # arrange figures fig1 = sg.fromstring(mol_svg) fig2 = sg.fromstring(feat_svg) plot1 = fig1.getroot() plot2 = fig2.getroot() plot1.moveto(10, -40) plot2.moveto(0, 65) svg = sc.Figure(&quot;16cm&quot;, &quot;6cm&quot;, plot1.scale(0.05), plot2.scale(0.05), ).tostr() SVG(svg) . . N H O N 2021-02-20T12:31:45.855792 image/svg+xml Matplotlib v3.3.2, https://matplotlib.org/ # interactive plot does not work in the final page # import svgutils.compose as sc import svgutils.transform as sg from ipywidgets import interact, interactive, fixed from IPython.display import SVG from io import BytesIO def drawit(m, atomId=0): atom = m.GetAtomWithIdx(atomId) feat = atom_features(atom) # draw molecule with highlight d = rdMolDraw2D.MolDraw2DSVG(200, 150) rdMolDraw2D.PrepareAndDrawMolecule(d, m, highlightAtoms=(atom.GetIdx(),)) d.FinishDrawing() mol_svg = d.GetDrawingText() # draw feature fig = plt.figure(figsize=(3, 0.8), dpi=150) ax = fig.add_subplot(111) im = ax.imshow([feat], interpolation=&#39;nearest&#39;, cmap=&#39;viridis&#39;, aspect=&#39;auto&#39;) plt.xlabel(&#39;atom feature&#39;) ax.set_yticks([]) img = BytesIO() plt.tight_layout() plt.savefig(img, transparent=True, format=&#39;svg&#39;) plt.close(fig) feat_svg = img.getvalue().decode() # arrange figures fig1 = sg.fromstring(mol_svg) fig2 = sg.fromstring(feat_svg) plot1 = fig1.getroot() plot2 = fig2.getroot() plot1.moveto(10, -40) plot2.moveto(0, 65) svg = sc.Figure(&quot;16cm&quot;, &quot;6cm&quot;, plot1.scale(0.05), plot2.scale(0.05), ).tostr() return SVG(svg) interact(drawit, m=fixed(mol), atomId=(0, mol.GetNumAtoms()-1)); . . Bond Features . The bond feature is even more simpler. The bond feature vector consists of one-hot encoding of bond type (single, double, triple, aromatic) and whether the bond is conjugated or not and whether in the ring or not. . def bond_features(bond: Chem.rdchem.Bond): &quot;&quot;&quot;Builds a feature vector for a bond. &quot;&quot;&quot; if bond is None: fbond = [1] + [0] * (BOND_FDIM - 1) else: bt = bond.GetBondType() fbond = [ 0, # bond is not None bt == Chem.rdchem.BondType.SINGLE, bt == Chem.rdchem.BondType.DOUBLE, bt == Chem.rdchem.BondType.TRIPLE, bt == Chem.rdchem.BondType.AROMATIC, (bond.GetIsConjugated() if bt is not None else 0), (bond.IsInRing() if bt is not None else 0) ] fbond += onek_encoding_unk(int(bond.GetStereo()), list(range(6))) return fbond . # example molecule smiles = &#39;c1ccccc1NC(=O)CC1cncc1&#39; mol = Chem.MolFromSmiles(smiles) # let&#39;s take a look at the first bond bond1 = mol.GetBondWithIdx(0) # C=C aromatic bond assert bond1.GetBeginAtom().GetSymbol() == &#39;C&#39; assert bond1.GetEndAtom().GetSymbol() == &#39;C&#39; feat1 = bond_features(bond1) assert feat1[4] == 1 # aromatic assert feat1[6] == 1 # ring # highlight which bond with Idx 0 d = rdMolDraw2D.MolDraw2DSVG(300, 150) rdMolDraw2D.PrepareAndDrawMolecule(d, mol, highlightBonds=(0,)) d.FinishDrawing() svg = d.GetDrawingText() SVG(svg) . . N H O N fig = plt.figure(figsize=(4, 0.2)) ax = fig.add_subplot(111) im = ax.imshow(np.array(feat1)[np.newaxis, :], interpolation=&#39;None&#39;, cmap=&#39;viridis&#39;, aspect=&#39;auto&#39;) plt.xlabel(&#39;bond feature&#39;) ax.set(yticklabels=[]) ax.tick_params(left=False) # remove the ticks plt.show() . . Above is the feature vector of the 0th bond. This bond is aromatic, conjugated, and in a ring. Let&#39;s take a look at another bond feature and see how it is different from the 0th bond feature vector. . # highlight which bond with Idx 0 d = rdMolDraw2D.MolDraw2DSVG(300, 150) rdMolDraw2D.PrepareAndDrawMolecule(d, mol, highlightBonds=(7,)) d.FinishDrawing() svg = d.GetDrawingText() SVG(svg) . . N H O N bond2 = mol.GetBondWithIdx(7) # C=C aromatic bond feat2 = bond_features(bond2) fig = plt.figure(figsize=(4, 0.2)) ax = fig.add_subplot(111) im = ax.imshow(np.array(feat2)[np.newaxis, :], interpolation=&#39;None&#39;, cmap=&#39;viridis&#39;, aspect=&#39;auto&#39;) plt.xlabel(&#39;bond feature&#39;) ax.set(yticklabels=[]) ax.tick_params(left=False) # remove the ticks plt.show() . . Now you can see this bond is double bond, conjugated, and not in a ring. Let&#39;s display the bond feature vectors of every chemical bond in the molecule. . feats = [] indices = [] for i in range(mol.GetNumBonds()): bond = mol.GetBondWithIdx(i) feat = bond_features(bond) feats.append(feat) indices.append(i) fig = plt.figure(figsize=(4, 0.25 * mol.GetNumBonds())) ax = fig.add_subplot(111) im = ax.imshow(feats, interpolation=&#39;None&#39;, cmap=&#39;viridis&#39;, aspect=&#39;auto&#39;) plt.xlabel(&#39;bond feature&#39;) plt.ylabel(&#39;bond index&#39;) ax.set_yticks(indices) ax.set_yticklabels(indices) ax.tick_params(left=False) # remove the ticks plt.show() . . Graph featurizaation . chemprop defines the molecular graph as the code shown below. The MolGraph itself is pretty straightforward; iterates over atoms and bonds and stores atom feature and bond feature vectors into f_atoms and f_bonds attributes and construct neighboring atom indices. . class MolGraph: def __init__(self, mol, atom_descriptors=None): # Convert SMILES to RDKit molecule if necessary if type(mol) == str: mol = Chem.MolFromSmiles(mol) self.n_atoms = 0 # number of atoms self.n_bonds = 0 # number of bonds self.f_atoms = [] # mapping from atom index to atom features self.f_bonds = [] # mapping from bond index to concat(in_atom, bond) features self.a2b = [] # mapping from atom index to incoming bond indices self.b2a = [] # mapping from bond index to the index of the atom the bond is coming from self.b2revb = [] # mapping from bond index to the index of the reverse bond # Get atom features self.f_atoms = [atom_features(atom) for atom in mol.GetAtoms()] if atom_descriptors is not None: self.f_atoms = [f_atoms + descs.tolist() for f_atoms, descs in zip(self.f_atoms, atom_descriptors)] self.n_atoms = len(self.f_atoms) # Initialize atom to bond mapping for each atom for _ in range(self.n_atoms): self.a2b.append([]) # Get bond features for a1 in range(self.n_atoms): for a2 in range(a1 + 1, self.n_atoms): bond = mol.GetBondBetweenAtoms(a1, a2) if bond is None: continue f_bond = bond_features(bond) self.f_bonds.append(self.f_atoms[a1] + f_bond) self.f_bonds.append(self.f_atoms[a2] + f_bond) # Update index mappings b1 = self.n_bonds b2 = b1 + 1 self.a2b[a2].append(b1) # b1 = a1 --&gt; a2 self.b2a.append(a1) self.a2b[a1].append(b2) # b2 = a2 --&gt; a1 self.b2a.append(a2) self.b2revb.append(b2) self.b2revb.append(b1) self.n_bonds += 2 . Let&#39;s take a look at the atom and the bond features it builds internally. The atom features are exactly same as what we discussed in the previous section. . smiles = &#39;c1ccccc1NC(=O)CC1cncc1&#39; mol = Chem.MolFromSmiles(smiles) mol_graph = MolGraph(smiles) . # atom features fig = plt.figure(figsize=(12, 4)) ax = fig.add_subplot(111) im = ax.imshow(mol_graph.f_atoms, interpolation=&#39;None&#39;, cmap=&#39;viridis&#39;, aspect=&#39;auto&#39;) ax.set_yticks(list(range(mol_graph.n_atoms))) ax.set_yticklabels(list(range(mol_graph.n_atoms))) ax.tick_params(left=False) # remove the ticks plt.xlabel(&#39;atom feature&#39;) plt.ylabel(&#39;atom index&#39;) plt.show() . . The &quot;bond&quot; in the molecular graph represents directed bonds. For example, there are two bonds, b1 and b2 between the atoms a1 and a2. The bond b1 is a bond from the atom a1 to atom a2 and the bond b2 is a bond from the atom a2 to a1. The bond feature is then constructed by concatenate the incoming atom (originating atom) feature and the bond feature. . # bond features : atom feature + bond feature # bond features are added as nested atoms loop. # For each bond, a1-&gt;a2 and a2-&gt;a1 are added. So, more bond features than NumBonds fig = plt.figure(figsize=(12, 8)) ax = fig.add_subplot(111) im = ax.imshow(mol_graph.f_bonds, interpolation=&#39;None&#39;, cmap=&#39;viridis&#39;, aspect=&#39;auto&#39;) ax.set_yticks(list(range(mol_graph.n_bonds))) ax.set_yticklabels(list(range(mol_graph.n_bonds))) ax.tick_params(left=False) # remove the ticks plt.xlabel(&#39;bond feature&#39;) plt.ylabel(&#39;bond index&#39;) plt.show() . . The attributes a2b, b2a, and b2revb contains various mapping of atom index to bond indices, bond index to atom index, and reverse bond index. These are required for the message passing to work properly. . Message passing . Now we are ready to dig into the most interesting part of MPNN architecture. The messages are passed around according to the connectivity, and the message evolves as it travels around the nodes. . The message passing phase consists of $T$ steps of update cycles. In each step $t$, hidden state hidden state $h_{vw}^t$ and message $m_{vw}^t$ are updated using message function $M_t$ and vertex update function $U_t$. Each message and hidden states are associated with nodes $v$ and $w$. Note the direction of message matters, so $h_{vw}^t$ and $m_{vw}^t$ are different from $h_{wv}^t$ and $m_{wv}^t$. . $$m_v^{t+1} = large sum_{k in {N(v)w }}^{} M_t(x_v, x_w, h_{kv}^t)$$ . $$h_{vw}^{t+1} = U_t(h_{vw}^t, m_{vw}^{t+1})$$ . The initial hidden state for each node is defined as . $$h_{vw}^0 = tau (W_i mathrm{cat} (x_v, e_{vw}))$$ . where $W_i$ is a learned matrix ($ mathbb{R}^{h times h_i}$), $ mathrm{cat} (x_v, e_{vw})$ is the concatenation of atom features ($ mathbb{R}^{h_i}$), $x_v$ and the bond feature $e_{vw}$ for bond $vw$, and the $ tau$ is the activation function. . chemprop uses very simple message passing function and edge update function: . $$M_t(x_v, x_w, h_{vw}^t) = h_{vw}^t$$ . $$U_t(h_{vw}^t, m_{vw}^{t+1}) = U(h_{vw}^t, m_{vw}^{t+1}) = tau (h_{vw}^0 + W_m m_{vw}^{t+1})$$. . The $W_m$ is a learned matrix ($ mathbb{R}^{h times h}$) . Finally, the atom representation of molecule is computed by summing over all incoming bond features. . $$m_v = sum_{k in N(v)} h_{kv}^t$$ . $$h_v = tau(W_a mathrm{cat} (x_v, m_v))$$ . where $W_a$ is a learned matrix ($ mathbb{R}^{h times h}$). The readout phase of the D-MPNN uses the readout function, $R$, which is a simple summation of all the atom hidden states, which subsequently used in a feed-forward network for predicting the molecular properties. . $$h = sum_{v in G} h_v$$ . Let&#39;s get into to the code and see how above is implemented. . Initial message . The initial hidden state for each node is defined as . $$h_{vw}^0 = tau (W_i mathrm{cat} (x_v, e_{vw}))$$ . # prepare the tensors for message passing bond_fdim = get_bond_fdim() atom_fdim = get_atom_fdim() n_atoms = 1 # number of atoms (start at 1 b/c need index 0 as padding) n_bonds = 1 # number of bonds (start at 1 b/c need index 0 as padding) a_scope = [] # list of tuples indicating (start_atom_index, num_atoms) for each molecule b_scope = [] # list of tuples indicating (start_bond_index, num_bonds) for each molecule # All start with zero padding so that indexing with zero padding returns zeros f_atoms = [[0] * atom_fdim] # atom features f_bonds = [[0] * bond_fdim] # combined atom/bond features a2b = [[]] # mapping from atom index to incoming bond indices b2a = [0] # mapping from bond index to the index of the atom the bond is coming from b2revb = [0] # mapping from bond index to the index of the reverse bond f_atoms.extend(mol_graph.f_atoms) f_bonds.extend(mol_graph.f_bonds) for a in range(mol_graph.n_atoms): a2b.append([b + n_bonds for b in mol_graph.a2b[a]]) for b in range(mol_graph.n_bonds): b2a.append(n_atoms + mol_graph.b2a[b]) b2revb.append(n_bonds + mol_graph.b2revb[b]) a_scope.append((n_atoms, mol_graph.n_atoms)) b_scope.append((n_bonds, mol_graph.n_bonds)) n_atoms += mol_graph.n_atoms n_bonds += mol_graph.n_bonds max_num_bonds = max(1, max(len(in_bonds) for in_bonds in a2b)) # max with 1 to fix a crash in rare case of all single-heavy-atom mols f_atoms = torch.FloatTensor(f_atoms) f_bonds = torch.FloatTensor(f_bonds) a2b = torch.LongTensor([a2b[a] + [0] * (max_num_bonds - len(a2b[a])) for a in range(n_atoms)]) b2a = torch.LongTensor(b2a) b2revb = torch.LongTensor(b2revb) . . # define and initialize leanred matrix input_dim = get_bond_fdim() atom_fdim = get_atom_fdim() W_i = nn.Linear(input_dim, args.hidden_size, bias=args.bias) w_h_input_size = args.hidden_size W_h = nn.Linear(w_h_input_size, args.hidden_size, bias=args.bias) W_o = nn.Linear(atom_fdim + args.hidden_size, args.hidden_size) act_func = nn.ReLU() # initial message input = W_i(torch.FloatTensor(f_bonds)) # num_bonds x hidden_size message = act_func(input) . fig = plt.figure(figsize=(12, 14)) ax = fig.add_subplot(211) im = ax.imshow(mol_graph.f_bonds, interpolation=&#39;None&#39;, cmap=&#39;viridis&#39;, aspect=&#39;auto&#39;) ax.set_yticks(list(range(mol_graph.n_bonds))) ax.set_yticklabels(list(range(mol_graph.n_bonds))) ax.tick_params(left=False) # remove the ticks plt.xlabel(&#39;bond feature&#39;) plt.ylabel(&#39;bond index&#39;) plt.title(&#39;Initial bond feature&#39;) ax = fig.add_subplot(212) im = ax.imshow(message.detach().numpy(), interpolation=&#39;None&#39;, cmap=&#39;viridis&#39;, aspect=&#39;auto&#39;) ax.set_yticks(list(range(mol_graph.n_bonds + 1))) ax.set_yticklabels(list(range(mol_graph.n_bonds + 1))) ax.tick_params(left=False) # remove the ticks plt.xlabel(&#39;hidden state&#39;) plt.ylabel(&#39;bond index&#39;) plt.title(&#39;Initial message&#39;) plt.show() . . Message Passing . The message passing phase consists of $T$ steps of composing messages and hidden state according to the message function and the update function. . $$m_v^{t+1} = large sum_{k in {N(v)w }}^{} h_{vw}^t$$ . $$h_{vw}^{t+1} = tau (h_{vw}^0 + W_m m_{vw}^{t+1})$$ . Below, we will try 3 cycles of message passing. . def index_select_ND(source: torch.Tensor, index: torch.Tensor) -&gt; torch.Tensor: &quot;&quot;&quot;Selects the message features from source corresponding to the atom or bond indices in index. &quot;&quot;&quot; index_size = index.size() # (num_atoms/num_bonds, max_num_bonds) suffix_dim = source.size()[1:] # (hidden_size,) final_size = index_size + suffix_dim # (num_atoms/num_bonds, max_num_bonds, hidden_size) target = source.index_select(dim=0, index=index.view(-1)) # (num_atoms/num_bonds * max_num_bonds, hidden_size) target = target.view(final_size) # (num_atoms/num_bonds, max_num_bonds, hidden_size) return target for depth in range(3): # m(a1 -&gt; a2) = [sum_{a0 in nei(a1)} m(a0 -&gt; a1)] - m(a2 -&gt; a1) # message a_message = sum(nei_a_message) rev_message nei_a_message = index_select_ND(message, a2b) # num_atoms x max_num_bonds x hidden a_message = nei_a_message.sum(dim=1) # num_atoms x hidden rev_message = message[b2revb] # num_bonds x hidden message = a_message[b2a] - rev_message # num_bonds x hidden message = W_h(message) message = act_func(input + message) # num_bonds x hidden_size . fig = plt.figure(figsize=(12, 7)) ax = fig.add_subplot(111) im = ax.imshow(a_message[b2a].detach().numpy(), interpolation=&#39;None&#39;, cmap=&#39;viridis&#39;, aspect=&#39;auto&#39;) ax.set_yticks(list(range(mol_graph.n_bonds + 1))) ax.set_yticklabels(list(range(mol_graph.n_bonds + 1))) ax.tick_params(left=False) # remove the ticks plt.xlabel(&#39;hidden state&#39;) plt.ylabel(&#39;bond index&#39;) plt.title(&#39;Messages after 3 steps of message passing&#39;) plt.show() . . Readout Phase . Finally, the atom representation of molecule is computed by summing over for all incoming bond features. . $$m_v = sum_{k in N(v)} h_{kv}^t$$ . $$h_v = tau(W_a mathrm{cat} (x_v, m_v))$$ . where $W_a$ is a learned matrix ($ mathbb{R}^{h times h}$). The readout phase of the D-MPNN uses the readout function, $R$, which is a simple summation of all the atom hidden states, which subsequently used in a feed-forward network for predicting the molecular properties. . $$h = sum_{v in G} h_v$$ . nei_a_message = index_select_ND(message, a2b) # num_atoms x max_num_bonds x hidden a_message = nei_a_message.sum(dim=1) # num_atoms x hidden a_input = torch.cat([f_atoms, a_message], dim=1) # num_atoms x (atom_fdim + hidden) atom_hiddens = act_func(W_o(a_input)) # num_atoms x hidden . fig = plt.figure(figsize=(12, 4)) ax = fig.add_subplot(111) im = ax.imshow(atom_hiddens.detach().numpy(), interpolation=&#39;None&#39;, cmap=&#39;viridis&#39;, aspect=&#39;auto&#39;) ax.set_yticks(list(range(mol_graph.n_atoms + 1))) ax.set_yticklabels(list(range(mol_graph.n_atoms + 1))) ax.tick_params(left=False) # remove the ticks plt.xlabel(&#39;hidden state&#39;) plt.ylabel(&#39;atom index&#39;) plt.title(&#39;Final hidden state for each atom&#39;) plt.show() . . Now we sum the hidden states to form the final molecular vector. This vector is called &quot;learned molecular vector&quot; and used in property prediction using feed-forward network. At this point, we have not trained the leanred matrices and the hidden states are close to random numbers. In the next post, I&#39;ll try t . This learned molecular vector is equivalent to molecular fingerprint, however, unlike the fingerprint, this representation can change for different dataset to better represents the nature of the data, which is the basis of how graph neural network can outperform the traditional machine learning approaches using fingerprint only. . mol_vecs = [] for i, (a_start, a_size) in enumerate(a_scope): if a_size == 0: mol_vecs.append(cached_zero_vector) else: cur_hiddens = atom_hiddens.narrow(0, a_start, a_size) mol_vec = cur_hiddens # (num_atoms, hidden_size) mol_vec = mol_vec.sum(dim=0) / a_size mol_vecs.append(mol_vec) mol_vecs = torch.stack(mol_vecs, dim=0) # (num_molecules, hidden_size) . fig = plt.figure(figsize=(12, 0.2)) ax = fig.add_subplot(111) im = ax.imshow(mol_vecs.detach().numpy(), interpolation=&#39;None&#39;, cmap=&#39;viridis&#39;, aspect=&#39;auto&#39;) ax.set_yticks([]) ax.tick_params(left=False) # remove the ticks plt.xlabel(&#39;hidden state&#39;) plt.title(&#39;Learned Molecular Vector&#39;) plt.show() . . Conclusion . Graph neural network fits well in representing molecule. It was interesting to take a look into how chemprop compute the learned molecular vector. This gave me a better understanding of MPNN and some aspects that I could experiment with. . Right before the readout phase, the atom-centered message or hidden state associated for the edge, could be used for atom centered properties, such as pKa or NMR chemical shift. | The atom and bond feature appears very simple. chemprop has an option that can use features from other toolkit and it does improves the performance of prediction. | The network only considered bonded interactions, however, atoms do interact even if they are not bonded. Such interaction is completely ignored in MPNN. | The rate of information transfer can be faster if we adopt a coarse network where the node are connected to not only neighbors but neighbor-of-neighbors or a network of functional groups. | Some kind of attention algorithm might also be useful to improve interpretability of the network. | .",
            "url": "https://sunhwan.github.io/blog/2021/02/20/Learning-Molecular-Representation-Using-Graph-Neural-Network-Molecular-Graph.html",
            "relUrl": "/2021/02/20/Learning-Molecular-Representation-Using-Graph-Neural-Network-Molecular-Graph.html",
            "date": " • Feb 20, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Ligand SASA in Protein Pocket",
            "content": "Motivation . Solvent-accessible surface area (SASA) is an important descriptor in ligand binding. The extent of ligand SASA value decrease upon binding indicates whether the ligand is deeply buried or not upon binding to the pocket. RDKit provides SASA value calculation, which is based on FreeSASA package. . %matplotlib inline import matplotlib.pyplot as plt from io import BytesIO import pandas as pd import numpy as np from rdkit.Chem import PandasTools from rdkit import Chem from rdkit.Chem import AllChem from rdkit.Chem import DataStructs from rdkit.Chem import rdMolDescriptors from rdkit.Chem import rdRGroupDecomposition from rdkit.Chem.Draw import IPythonConsole #Needed to show molecules from rdkit.Chem import Draw from rdkit.Chem import rdDepictor from rdkit.Chem.Draw import rdMolDraw2D from rdkit.Chem.Draw.MolDrawing import MolDrawing, DrawingOptions #Only needed if modifying defaults DrawingOptions.bondLineWidth=1.8 IPythonConsole.ipython_useSVG=True from rdkit import RDLogger RDLogger.DisableLog(&#39;rdApp.warning&#39;) import rdkit import py3Dmol print(rdkit.__version__) . . 2020.03.2 . Example . Let&#39;s use ABL2-Imatinib complex (PDB:3GVU) for an example. I first downloaded the file and removed the water and the bound ligands. . prot = Chem.MolFromPDBFile(&#39;files/3gvu.pdb&#39;) lig = Chem.MolFromMolFile(&#39;files/STI.sdf&#39;) viewer = py3Dmol.view(width=300, height=300) viewer.addModel(Chem.MolToPDBBlock(prot), &#39;mol&#39;) viewer.addModel(Chem.MolToPDBBlock(lig), &#39;pdb&#39;) viewer.setStyle({&#39;chain&#39;: &#39;A&#39;}, {&#39;cartoon&#39;:{&#39;color&#39;:&#39;spectrum&#39;}}) viewer.setStyle({&#39;resn&#39;: &#39;UNL&#39;}, {&#39;stick&#39;:{}}) viewer.zoomTo({&#39;resn&#39;: &#39;UNL&#39;}) viewer.show() . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . Let&#39;s define a function that compute SASA. The code is taken from here . from rdkit.Chem import rdFreeSASA # compute ligand SASA lig_h = Chem.AddHs(lig, addCoords=True) # Get Van der Waals radii (angstrom) ptable = Chem.GetPeriodicTable() radii = [ptable.GetRvdw(atom.GetAtomicNum()) for atom in lig_h.GetAtoms()] # Compute solvent accessible surface area lig_sasa = rdFreeSASA.CalcSASA(lig_h, radii) . comp = Chem.CombineMols(prot, lig) comp_h = Chem.AddHs(comp, addCoords=True) # Get Van der Waals radii (angstrom) ptable = Chem.GetPeriodicTable() radii = [ptable.GetRvdw(atom.GetAtomicNum()) for atom in comp_h.GetAtoms()] # Compute solvent accessible surface area comp_sasa = rdFreeSASA.CalcSASA(comp_h, radii) . print(lig_sasa, comp_sasa) . 849.5659988403745 14213.44708409188 . Note that comp_sasa is the overall SASA of both protein and ligand. We want to compute the SASA of ligand only while in the binding pocket. RDKit stores the per-atom SASA values in the atom object. . comp_lig = Chem.GetMolFrags(comp_h, asMols=True)[-1] # ligand is the last component lig_sasa_free = 0 for a in lig_h.GetAtoms(): lig_sasa_free += float(a.GetProp(&quot;SASA&quot;)) lig_sasa_bound = 0 for a in comp_lig.GetAtoms(): lig_sasa_bound += float(a.GetProp(&quot;SASA&quot;)) . print(&quot;Ligand SASA (free) =&quot;, lig_sasa_free) print(&quot;Ligand SASA (bound) =&quot;, lig_sasa_bound) print(&quot;Ligand SASA difference =&quot;, lig_sasa_free - lig_sasa_bound) . Ligand SASA (free) = 849.5659988403745 Ligand SASA (bound) = 68.71464272335984 Ligand SASA difference = 780.8513561170147 . Reduce computation time . Let&#39;s put above in a functional call and measure the timing. . from rdkit.Chem import rdFreeSASA def compute_sasa(mol): # Get Van der Waals radii (angstrom) ptable = Chem.GetPeriodicTable() radii = [ptable.GetRvdw(atom.GetAtomicNum()) for atom in mol.GetAtoms()] # Compute solvent accessible surface area sasa = rdFreeSASA.CalcSASA(mol, radii) return sasa def compute_ligand_sasa_pocket(prot, lig): # compute complex SASA comp = Chem.CombineMols(prot, lig) comp_h = Chem.AddHs(comp, addCoords=True) comp_sasa = compute_sasa(comp_h) # compute ligand SASA in pocket comp_lig = Chem.GetMolFrags(comp_h, asMols=True, sanitizeFrags=False)[-1] # ligand is the last component lig_sasa_bound = sum([float(a.GetProp(&quot;SASA&quot;)) for a in comp_lig.GetAtoms()]) return lig_sasa_bound . sasa_free = compute_sasa(lig) sasa_bound = compute_ligand_sasa_pocket(prot, lig) print(&quot;Ligand SASA (free) =&quot;, sasa_free) print(&quot;Ligand SASA (bound) =&quot;, sasa_bound) print(&quot;Ligand SASA difference =&quot;, sasa_free - sasa_bound) . Ligand SASA (free) = 767.8208065148369 Ligand SASA (bound) = 68.71464272335984 Ligand SASA difference = 699.1061637914771 . Let&#39;s measure the timing of this function call. I suspect this is not particularly fast because the code needs to compute SASA of all protein atoms as well. Perhaps we can make this faster by only computing SASA within certain distance from the ligand atoms. . %timeit compute_ligand_sasa_pocket(prot, lig) . 323 ms ± 1.39 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) . def compute_ligand_sasa_pocket_cutoff(prot, lig, cutoff=8): lig_conf = lig.GetConformer() lig_xyz = lig_conf.GetPositions() prot_conf = prot.GetConformer() prot_xyz = conf.GetPositions() # minimum distance between protein atoms and ligand atoms r = np.min(np.linalg.norm(prot_xyz[:, np.newaxis, :] - lig_xyz[np.newaxis, :, :], axis=2), axis=1) indices = np.argwhere(r &gt; cutoff).flatten() mol = Chem.RWMol(prot) for idx in sorted(indices, reverse=True): mol.RemoveAtom(int(idx)) return compute_ligand_sasa_pocket(mol, lig) . sasa_free = compute_sasa(lig) sasa_bound = compute_ligand_sasa_pocket_cutoff(prot, lig, 5) print(&quot;Ligand SASA (free) =&quot;, sasa_free) print(&quot;Ligand SASA (bound) =&quot;, sasa_bound) print(&quot;Ligand SASA difference =&quot;, sasa_free - sasa_bound) . Ligand SASA (free) = 767.8208065148369 Ligand SASA (bound) = 89.35880016654482 Ligand SASA difference = 678.4620063482921 . With the cutoff distance of 5 Å, we get slightly larger SASA value in the bound state. We can improve this by increasing the cutoff distance. . cutoff_values = [5, 6, 7, 8, 9, 10] sasa_bound_values = [compute_ligand_sasa_pocket_cutoff(prot, lig, c) for c in cutoff_values] plt.plot(cutoff_values, sasa_bound_values) plt.xlabel(&#39;Cutoff&#39;) plt.ylabel(&#39;SASA&#39;) plt.show() . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2021-02-05T11:44:10.373090 image/svg+xml Matplotlib v3.3.2, https://matplotlib.org/ The SASA value converged after 7 Å cutoff. Let&#39;s compute the function call speed using 8 Å as cutoff. . %timeit compute_ligand_sasa_pocket_cutoff(prot, lig, 8) . 229 ms ± 20.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) . In my laptop, I got 323 ms (without cutoff) vs 229 ms (with cutoff), which represents about 40% speedup. .",
            "url": "https://sunhwan.github.io/blog/2021/02/04/RDKit-Protein-Ligand-SASA.html",
            "relUrl": "/2021/02/04/RDKit-Protein-Ligand-SASA.html",
            "date": " • Feb 4, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Build 3D coordinates of congeneric series",
            "content": "Motivation . I often have to modify a given molecule to introduce a set of modification to make congeneric series. AllChem.ConstrainedEmbed in RDKit could provide such function. See below blog posts for an example: . http://rdkit.blogspot.com/2013/12/using-allchemconstrainedembed.html | https://iwatobipen.wordpress.com/2019/06/04/constrain-embedding-with-mcs-as-a-core-rdkit-chemoinformatics/ | https://www.blopig.com/blog/2019/06/constrained-embedding-with-rdkit/ | . However, AllChem.ConstrinedEmbed uses MCS algorithm, and the MCS sometimes did not yielded the core that I desired, which resulted in a completely wrong alignment between the parent and the newly modified molecule. . So, I wrote a small function that takes the SMARTS pattern, and explicitly takes the coordinates then embed the rest of the coordinates. . from io import BytesIO import pandas as pd import numpy as np from rdkit.Chem import PandasTools from rdkit import Chem from rdkit.Chem import AllChem from rdkit.Chem import DataStructs from rdkit.Chem import rdMolDescriptors from rdkit.Chem import rdRGroupDecomposition from rdkit.Chem.Draw import IPythonConsole #Needed to show molecules from rdkit.Chem import Draw from rdkit.Chem import rdDepictor from rdkit.Chem.Draw import rdMolDraw2D from rdkit.Chem.Draw.MolDrawing import MolDrawing, DrawingOptions #Only needed if modifying defaults DrawingOptions.bondLineWidth=1.8 IPythonConsole.ipython_useSVG=True from rdkit import RDLogger RDLogger.DisableLog(&#39;rdApp.warning&#39;) import rdkit import py3Dmol print(rdkit.__version__) . . 2020.03.2 . Example . Let&#39;s use Imatinib for the parent molecule as an example. . imatinib = Chem.MolFromMolFile(&#39;files/STI.sdf&#39;) imatinib_2d = Chem.RemoveHs(imatinib) AllChem.Compute2DCoords(imatinib_2d) imatinib_2d . N N N NH HN O N N And suppose we want to replace the piperazine to a phenyl. . mol_new = Chem.MolFromSmiles(&#39;Cc1ccc(NC(=O)c2ccc(c3ccccc3)cc2)cc1Nc1nccc(-c2cccnc2)n1&#39;) mol_new . HN O NH N N N SMARTS Pattern . smarts = &#39;[#6]1:[#6]:[#7]:[#6]:[#6](:[#6]:1)-[#6]1:[#7]:[#6](:[#7]:[#6]:[#6]:1)-[#7]-[#6]1:[#6]:[#6](:[#6]:[#6]:[#6]:1-[#6])-[#7]-[#6](-[#6]1:[#6]:[#6]:[#6](:[#6]:[#6]:1))=[#8]&#39; p = Chem.MolFromSmarts(smarts) p . N N N N N O imatinib_2d.GetSubstructMatch(p) imatinib_2d . N N N NH HN O N N mol_new.GetSubstructMatch(p) mol_new . HN O NH N N N Build the new conformer . from rdkit.Chem import rdFMCS from rdkit.Chem import rdDistGeom from rdkit.Chem.rdForceFieldHelpers import UFFGetMoleculeForceField def build(ref, m, smarts): mol = Chem.AddHs(m) p = Chem.MolFromSmarts(smarts) match1 = ref.GetSubstructMatch(p) match2 = mol.GetSubstructMatch(p) coordMap = {} coreConf = ref.GetConformer(0) for i, idxI in enumerate(match2): corePtI = coreConf.GetAtomPosition(match1[i]) coordMap[idxI] = corePtI algMap = [(j, match1[i]) for i, j in enumerate(match2)] tdist = 0.25 confid = AllChem.EmbedMolecule(mol, coordMap=coordMap) rms = AllChem.AlignMol(mol, ref, atomMap=algMap) ff = UFFGetMoleculeForceField(mol, confId=0) conf = ref.GetConformer() for i in range(len(match1)): p = conf.GetAtomPosition(match1[i]) pIdx = ff.AddExtraPoint(p.x, p.y, p.z, fixed=True) - 1 ff.AddDistanceConstraint(pIdx, match2[i], 0, tdist, 100.) ff.Initialize() n = 4 more = ff.Minimize(energyTol=1e-4, forceTol=1e-3) while more and n: more = ff.Minimize(energyTol=1e-4, forceTol=1e-3) n -= 1 # realign rms = AllChem.AlignMol(mol, ref, atomMap=algMap) return mol . mol_new = build(imatinib, mol_new, smarts) . You can see the new molecule have very similar coordinates except the newly added phenyl ring in 3D. . viewer = py3Dmol.view(width=300, height=300) viewer.addModel(Chem.MolToMolBlock(imatinib), &#39;mol&#39;) viewer.addModel(Chem.MolToMolBlock(mol_new), &#39;mol&#39;) viewer.setStyle({&quot;stick&quot;:{}}) viewer.zoomTo() viewer.show() . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . Note you can perform a fragment grafting instead of embedding. See https://pschmidtke.github.io/blog/rdkit/3d-editor/2021/01/23/grafting-fragments.html .",
            "url": "https://sunhwan.github.io/blog/2021/01/29/RDKit-Embed-Congeneric-Series.html",
            "relUrl": "/2021/01/29/RDKit-Embed-Congeneric-Series.html",
            "date": " • Jan 29, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://sunhwan.github.io/blog/2020/02/20/test.html",
            "relUrl": "/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://sunhwan.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://sunhwan.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

  
  

}